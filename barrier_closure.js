/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


goog.provide('virtualdesktops.BarrierClosure');



/**
 * A BarrierClosure provides a closure to call multiple times. When all
 * closures generated by get() have been called and the BarrierClosure has been
 * finalized, it executes the callback registered with then().
 *
 * Sample usage:
 *   var b = new BarrierClosure();
 *   someAsyncFunction(..., b.get());
 *   moreAsyncStuff(..., b.get());
 *   b.finalize();  // All get() calls have been done.
 *   b.then(function() {
 *     // Executes after both someAsyncFunction and moreAsyncStuff are done.
 *   });
 *
 * @constructor
 */
virtualdesktops.BarrierClosure = function() {
  /**
   * The callback to call when done.
   * @private {?function()}
   */
  this.callback_ = null;
  /**
   * The number of calls to wait for before calling the callback.
   * @private {number}
   */
  this.count_ = 0;
  /**
   * True if this barrier closure has been finalized.
   * @private {boolean}
   */
  this.finalized_ = false;
};


/**
 * Returns a closure, which must be actually called before the final callback is
 * executed.
 * @return {function()}
 */
virtualdesktops.BarrierClosure.prototype.get = function() {
  if (this.finalized_) {
    throw new Error('BarrierClosure has already been finalized');
  }
  ++this.count_;
  return (function() {
    --this.count_;
    this.maybeInvokeCallback_();
  }).bind(this);
};


/**
 * Finalizes the barrier closure. After this call, further calls to get() are
 * forbidden. Finalizing the barrier closure is necessary to tell the barrier
 * closure that no future calls to get() will happen, and thus that the count of
 * barriers cannot change any more.
 */
virtualdesktops.BarrierClosure.prototype.finalize = function() {
  if (this.finalized_) {
    throw new Error('BarrierClosure has already been finalized');
  }
  this.finalized_ = true;
  this.maybeInvokeCallback_();
};


/**
 * Sets the closure to call when all get closures have been called, and
 * executes it if no closures have been requested from get() or all already
 * have been called.
 * Must be called after all invocations to get().
 * @param {function()} callback The callback to call when done.
 */
virtualdesktops.BarrierClosure.prototype.then =
    function(callback) {
  if (this.callback_ != null) {
    throw new Error('BarrierClosure already has a callback');
  }
  this.callback_ = callback;
  this.maybeInvokeCallback_();
};


/**
 * Invoke the BarrierClosure's callback if all necessary conditions are
 * satisfied.
 * For this to invoke the callback at most once, the caller must ensure that
 * this only ever gets called after one of the following operations:
 * - decreasing this.count_,
 * - changing this.finalized_ from false to true,
 * - changing this.callback_ from null to non-null.
 * @private
 */
virtualdesktops.BarrierClosure.prototype.maybeInvokeCallback_ =
    function() {
  if (this.count_ == 0 && this.finalized_ && this.callback_ != null) {
    this.callback_();
  }
};
